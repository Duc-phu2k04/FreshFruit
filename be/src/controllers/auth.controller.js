import * as authService from '../services/auth.service.js';
import bcrypt from 'bcryptjs';
import User from '../models/user.model.js';
import Order from '../models/order.model.js';
import crypto from 'crypto';
import { sendMail } from '../services/mail.service.js';

// ƒêƒÉng k√Ω t√†i kho·∫£n
export const register = async (req, res) => {
  try {
    const { username, email, password, role } = req.body;
    const user = await authService.register(username, email, password, role);
    res.status(201).json({ message: 'ƒêƒÉng k√Ω th√†nh c√¥ng', user });
  } catch (err) {
    res.status(400).json({ error: err.message || 'ƒêƒÉng k√Ω th·∫•t b·∫°i' });
  }
};

// ƒêƒÉng nh·∫≠p
export const login = async (req, res) => {
  try {
    const { usernameOrEmail, password } = req.body;
    const { token, user } = await authService.login(usernameOrEmail, password);
    res.json({ message: 'ƒêƒÉng nh·∫≠p th√†nh c√¥ng', token, user });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

// L·∫•y to√†n b·ªô ng∆∞·ªùi d√πng
export const getAllUsers = async (req, res) => {
  try {
    const users = await User.find().select('-password');
    res.json(users);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: err.message || 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch ng∆∞·ªùi d√πng' });
  }
};

// L·∫•y ng∆∞·ªùi d√πng theo ID + l·ªãch s·ª≠ ƒë∆°n h√†ng
export const getUserById = async (req, res) => {
  try {
    const user = await User.findById(req.params.id).select('-password').lean();
    if (!user) return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng' });

    const orders = await Order.find({ user: req.params.id })
      .populate('items.product', 'name image price')
      .sort({ createdAt: -1 })
      .lean();

    user.orders = orders;

    res.json(user);
  } catch (error) {
    res.status(500).json({ message: 'L·ªói server khi l·∫•y th√¥ng tin ng∆∞·ªùi d√πng', error: error.message });
  }
};

// C·∫≠p nh·∫≠t ng∆∞·ªùi d√πng
export const updateUser = async (req, res) => {
  try {
    const { id } = req.params;
    const { username, email, phone, address, role, fullName } = req.body;

    const user = await User.findById(id);
    if (!user) return res.status(404).json({ message: 'Ng∆∞·ªùi d√πng kh√¥ng t√¨m th·∫•y.' });

    if (fullName) user.fullName = fullName;
    if (username) user.username = username;
    if (email) user.email = email;
    if (phone) user.phone = phone;
    if (address) user.address = address;
    if (role && ['user', 'admin'].includes(role)) {
      user.role = role;
    }

    const updatedUser = await user.save();
    res.status(200).json({ message: 'Th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t!', data: updatedUser });
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
};

// X√≥a ng∆∞·ªùi d√πng
export const deleteUser = async (req, res) => {
  try {
    const { id } = req.params;
    const deletedUser = await User.findByIdAndDelete(id);
    if (!deletedUser) {
      return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng' });
    }
    res.json({ message: 'X√≥a ng∆∞·ªùi d√πng th√†nh c√¥ng', user: deletedUser });
  } catch (err) {
    res.status(500).json({ error: 'L·ªói khi x√≥a ng∆∞·ªùi d√πng' });
  }
};

// Qu√™n m·∫≠t kh·∫©u
export const forgotPassword = async (req, res) => {
  try {
    const { email } = req.body;
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(404).json({ message: 'Email kh√¥ng t·ªìn t·∫°i trong h·ªá th·ªëng.' });
    }

    const newPassword = crypto.randomBytes(4).toString('hex');
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    user.password = hashedPassword;
    await user.save();

    const emailContent = `
Xin ch√†o ${user.username || 'b·∫°n'}, 

Ch√∫ng t√¥i ƒë√£ nh·∫≠n ƒë∆∞·ª£c y√™u c·∫ßu ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u cho t√†i kho·∫£n FreshFruit c·ªßa b·∫°n.

üîë M·∫≠t kh·∫©u m·ªõi c·ªßa b·∫°n l√†: ${newPassword}

Vui l√≤ng ƒëƒÉng nh·∫≠p v√† ƒë·ªïi m·∫≠t kh·∫©u ngay ƒë·ªÉ ƒë·∫£m b·∫£o an to√†n cho t√†i kho·∫£n.

Tr√¢n tr·ªçng,
ƒê·ªôi ng≈© FreshFruit
    `;

    await sendMail(
      email,
      'üîê M·∫≠t kh·∫©u m·ªõi t·ª´ h·ªá th·ªëng FreshFruit',
      emailContent
    );

    res.status(200).json({ message: 'M·∫≠t kh·∫©u m·ªõi ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n.' });
  } catch (error) {
    res.status(500).json({ message: 'L·ªói server', error: error.message });
  }
};

// ‚úÖ Th√™m: Ki·ªÉm tra username ho·∫∑c email ƒë√£ t·ªìn t·∫°i
export const checkDuplicate = async (req, res) => {
  try {
    const { username, email } = req.query;

    let query = {};
    if (username) query.username = username;
    if (email) query.email = email;

    const existingUser = await User.findOne(query);
    if (existingUser) {
      return res.status(200).json({ exists: true });
    }

    res.status(200).json({ exists: false });
  } catch (error) {
    res.status(500).json({ error: 'L·ªói ki·ªÉm tra t√†i kho·∫£n' });
  }
};
